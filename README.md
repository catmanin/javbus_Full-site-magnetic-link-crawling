# 项目名称: Javbus Full-site Magnet Link Crawler

## 1. 项目核心目标 (Project Goal)

本项目旨在创建一个全自动、高效率的网站内容抓取与管理系统。其核心任务是：
1.  有效**绕过 Javbus 的防爬虫机制**。
2.  通过**穷举番号**的方式，对全站影片页面进行扫描。
3.  **精确抓取**每个影片页面下所有的磁力链接，这需要模拟浏览器进行二次异步请求。
4.  对抓取到的磁力链接列表进行**智能排序**，筛选出最优链接（高清、字幕、大体积优先）。
5.  将影片信息和最优磁力链接**持久化存储**到 SQLite 数据库中。
6.  通过 **Flask** 构建一个简洁的 Web 界面，以表格形式展示数据。
7.  在 Web 界面上提供**一键批量复制磁力链接**的功能，方便用户直接将链接粘贴到 115、PikPak 等网盘进行离线下载。

## 2. 关键挑战与应对思路 (Crucial Challenges & Strategy)

### A. 绕过防爬机制 (Anti-Crawling Bypass)

这是项目成功的首要前提。Javbus 的防爬主要体现在对请求来源的验证上。

* **思路**: 模拟一个真实的、已登录（或已验证）的浏览器行为。
    1.  **获取有效 Cookie**:
        * **手动获取**: 在浏览器中正常访问 Javbus，完成可能出现的真人验证。
        * 打开开发者工具 (F12) -> 网络(Network) -> 随便点击一个请求 -> 在请求头(Request Headers)中找到 `Cookie` 项，复制其完整的字符串值。
        * 这个 Cookie 字符串将作为我们爬虫的“通行证”。
    2.  **在 Python 中使用 Cookie**:
        * `requests` 库不直接接受字符串形式的 Cookie。需要将其转换为 `RequestsCookieJar` 对象。
        * **实现方法**: 编写一个辅助函数，解析 Cookie 字符串（它是一个分号和空格分隔的键值对集合），并逐个添加到 `RequestsCookieJar` 实例中。
    3.  **构造请求头 (Headers)**:
        * 除了 `Cookie`，还必须模拟其他关键的浏览器请求头，尤其是 `User-Agent` 和 `Referer`。
        * `User-Agent` 应使用一个常见的浏览器标识。
        * `Referer` 应设置为 Javbus 网站自身的地址，模拟页面间的正常跳转。

### B. 磁力链接的异步获取 (Fetching Magnets via AJAX)

磁力链接并非直接存在于影片页面的 HTML 中，而是通过 JavaScript 异步加载的。

* **思路**: 模拟这个异步加载过程，这需要一个“两步走”的抓取策略。
    1.  **第一步: 抓取主页面，获取 `gid`**
        * 使用携带了完整请求头（包括处理好的 Cookie）的 `requests` 会话，GET 请求影片主页面 (`一级域名/{番号}`)。
        * 使用 `BeautifulSoup4` 解析返回的 HTML。
        * 在页面的 `<script>` 标签中，找到定义 `gid`, `uc`, `img` 等变量的 JavaScript 代码。
        * 使用正则表达式从这段 JS 代码中精确提取出 `gid` 的值。

    2.  **第二步: 模拟 AJAX 请求，获取磁力链接数据**
        * 通过分析浏览器开发者工具的网络(XHR)标签，找到当鼠标悬停在磁力按钮上时，浏览器实际发出的那个 AJAX 请求。
        * 这个请求的 URL 通常是 `domain/ajax/uncledatoolsbyajax.php`。
        * 它的请求参数 (Query Parameters) 包含我们上一步获取的 `gid` 以及其他一些固定或可计算的参数。
        * **关键**: 必须使用同一个 `requests` 会话 (Session)，携带同样的请求头（特别是 Cookie 和 Referer），来 GET 这个 AJAX URL。
        * 服务器会返回一小段 HTML 或 JSON，其中包含了真正的磁力链接、标题、文件大小等信息。使用 BeautifulSoup 或 `json` 模块解析即可。

## 3. 核心工作流程 (Core Workflow)

1.  **番号生成器**: 创建一个 Python 生成器函数，用于穷举 `ABC-123` 格式的番号。
2.  **主控循环**: 遍历番号生成器。
3.  **执行抓取**: 对每个番号执行上述的“两步走”抓取策略。
    * **失败处理**: 如果第一步返回 404 (页面不存在)，则记录并跳过。如果任何一步失败（如IP被禁、解析错误），同样记录错误并继续。
4.  **磁力链接排序**:
    * 获取到磁力链接列表后，编写一个排序函数。
    * 该函数为每个链接打分。评分标准：包含 `HD`、`1080p` 等关键词加分；包含 `字幕` 关键词加分；文件体积（从描述中提取 `GB`或`MB` 并转换）大的加分。
    * 选取分数最高的链接作为“最佳磁力链接”。
5.  **数据入库**: 将番号、影片标题、封面图链接、最佳磁力链接以及完整的磁力链接列表(JSON格式)存入 SQLite 数据库。使用 `INSERT OR IGNORE` 或 `INSERT OR REPLACE` 来避免重复或进行更新。
6.  **Flask 应用**:
    * 从数据库读取数据，传递给 HTML 模板。
    * 使用 Jinja2 模板引擎渲染出一个带有分页和搜索功能的表格。
    * 表格的最后一列是“操作”，包含一个指向最佳磁力链接的 `magnet:` 协议链接。

## 4. 数据库设计 (SQLite Schema)

**`movies` 表:**

| 字段名 (Column) | 数据类型 (Type) | 说明 (Notes) |
| :--- | :--- | :--- |
| `code` | TEXT | 主键。番号，如 `ABC-123`。 |
| `title` | TEXT | 影片标题。 |
| `cover_url` | TEXT | 封面图片链接。 |
| `release_date` | TEXT | 发行日期。 |
| `best_magnet` | TEXT | 通过排序算法筛选出的最优磁力链接。 |
| `all_magnets_json` | TEXT | 包含所有磁力链接信息的 JSON 字符串，用于备份或未来分析。 |
| `last_crawled_at` | TIMESTAMP | 本次抓取的时间戳。 |

## 5. Flask 应用设计思路

* **后端**:
    * `/`: 主页，分页显示所有数据。
    * `/search`: 接收查询参数，通过 `LIKE` 语句在数据库中搜索 `code` 或 `title`。
* **前端**:
    * 一个清爽的 HTML 表格。
    * **关键功能**: **批量复制磁力链接**。
        * 在表格上方放置一个“批量复制选中项”按钮。
        * 表格每行最前面增加一个复选框 (checkbox)。
        * **JavaScript 逻辑**: 当用户点击按钮时，JS 脚本会遍历所有被选中的复选框，找到其对应的磁力链接，将这些链接用换行符 (`\n`) 拼接成一个大字符串，然后调用 `navigator.clipboard.writeText()` API 将这个字符串写入用户的剪贴板。

## 6. 实施建议 (Phased Implementation)

由于项目复杂，建议分阶段进行开发和调试：

1.  **第一阶段: 攻克单页抓取**
    * **目标**: 成功抓取一个指定番号的所有磁力链接并打印出来。
    * **重点**: 完美实现“Cookie处理”和“两步走AJAX模拟”。这是整个项目最难的部分。

2.  **第二阶段: 构建批量爬虫**
    * **目标**: 将第一阶段的代码封装成函数，并结合番号生成器、数据库存储、错误处理，实现全自动批量抓取。

3.  **第三阶段: 开发 Web 展示界面**
    * **目标**: 搭建 Flask 应用，实现数据的查询、展示和核心的“批量复制”功能。

---

这份思路蓝图为您规划了从技术攻坚到最终应用的全过程，特别是突出了您提到的几个关键难点。您可以根据这个大纲，在有空时逐步实现每个模块的代码。
